import logging
from datetime import datetime, timezone
from typing import List

from homeassistant.components.calendar import (
    CalendarEntity,
    CalendarEvent,
    CalendarEntityFeature,
    CalendarEntityDescription
)
from homeassistant.core import callback
from homeassistant.helpers import entity_registry as er
from homeassistant.exceptions import HomeAssistantError

from .const import DOMAIN, LOGGER_NAME, SCHEDULE_UPDATED_EVENT
from .entity import AIEnergySchedulerEntity

_LOGGER = logging.getLogger(LOGGER_NAME)


async def async_setup_entry(hass, config_entry, async_add_entities):
    coordinator = hass.data[DOMAIN]["coordinator"]
    created_devices = {}
    calendars = []

    for device_id in coordinator.data.get("schedules", {}):
        _LOGGER.debug(f"Adding calendar for existing device: {device_id}")
        calendar = EnergyScheduleCalendar(coordinator, device_id)
        calendars.append(calendar)
        created_devices[device_id] = calendar
    async_add_entities(calendars)

    @callback
    def async_schedule_update(event):
        nonlocal created_devices
        current_devices = set(coordinator.data.get("schedules", {}).keys())
        created_device_ids = set(created_devices.keys())

        new_devices = current_devices - created_device_ids

        if new_devices:
            new_entities = []
            for device_id in new_devices:
                _LOGGER.debug(f"Adding calendar for new device: {device_id}")
                entity = EnergyScheduleCalendar(coordinator, device_id)
                new_entities.append(entity)
                created_devices[device_id] = entity
            async_add_entities(new_entities)

    config_entry.async_on_unload(
        hass.bus.async_listen(SCHEDULE_UPDATED_EVENT, async_schedule_update)
    )


class EnergyScheduleCalendar(AIEnergySchedulerEntity, CalendarEntity):
    _attr_supported_features = (
        # CalendarEntityFeature.CREATE_EVENT |
        CalendarEntityFeature.UPDATE_EVENT
    )
    entity_description = CalendarEntityDescription(
            key="calendar",
            name=f"Calendar",
    )

    async def async_get_events(self, hass, start_date: datetime, end_date: datetime) -> List[CalendarEvent]:
        """Return a list of calendar events for the specified date range."""
        intervals = self._get_intervals
        if not intervals:
            return []
        
        events = []
        for interval in intervals:
            if interval.start < end_date and interval.end > start_date:
                events.append(CalendarEvent(
                    start=interval.start,
                    end=interval.end,
                    summary=interval.command if not interval.command_override else interval.command_override,
                    description=f"Generated by AI, suggested command: {interval.command}",
                    uid=f"{self._device_id}-{interval.start.isoformat()}-{interval.end.isoformat()}"
                ))
        return events

    @property
    def event(self):
        """Return the current event as a CalendarEvent or None."""      
        interval = self._get_current_interval  # Assuming we want the first interval for the event property
        if not interval:
            _LOGGER.debug(f"No current interval found for device {self._device_id}")
            return None

        return CalendarEvent(
            start=interval.start,
            end=interval.end,
            summary=interval.command if not interval.command_override else interval.command_override,
            description=f"Generated by AI, suggested command: {interval.command}",
            #uid=f"{self._device_id}-{interval.start.isoformat()}"
            uid=f"{self._device_id}-{interval.start.isoformat()}-{interval.end.isoformat()}"
        )

    # async def async_handle_event(self, event):
    #     """Handle calendar event edit, update command & description by matching uid."""
    #     _LOGGER.warning(f"async_handle_event called for event: {event}")

    #     # extract event details
    #     event_start_time = event.get("dtstart")
    #     event_end_time = event.get("dtend")
    #     event_summary = event.get("summary")

    #     schedules = self.coordinator.data.get("schedules", {})
    #     device_schedule = schedules.get(self._device_id, {})
    #     intervals = device_schedule.get("intervals", [])

    #     # try to find the interval we want to update
    #     for interval in intervals:
    #         if interval.get("start") == event_start_time and interval.get("end") == event_end_time:
    #             _LOGGER.info(f"Found matching interval for device {self._device_id} with start {event_start_time} and end {event_end_time}")
    #             interval["description"] = f"Manual override, ai suggested command: {interval.get('command')}"
    #             interval["command"] = event_summary

    #             # self.hass.bus.async_fire(
    #             #     CALENDAR_OVERRIDE_EVENT,
    #             #     {
    #             #         "device_id": self._device_id,
    #             #         "intervals": intervals,
    #             #     },
    #             # )
    #             _LOGGER.info(f"Fired calendar override event for device {self._device_id} updating command to {interval['command']}")
    #             return

    # async def async_add_event(self, event, **kwargs):
    #     _LOGGER.debug("async_add_event called")
    #     await self.async_handle_event(event)

    async def async_update_event(self, event_id, event, **kwargs):
        # extract event details
        event_start_time = event.get("dtstart").isoformat()
        event_end_time = event.get("dtend").isoformat()
        event_summary = event.get("summary")

        schedules = self.coordinator.data.get("schedules", {})
        device_schedule = schedules.get(self._device_id, {})
        intervals = device_schedule.get("intervals", [])

        # try to find the interval we want to update
        for interval in intervals:
            if interval.get("start") == event_start_time and interval.get("end") == event_end_time:
                _LOGGER.debug(f"Found matching interval for device {self._device_id} with start {event_start_time} and end {event_end_time}")

                # update the interval with the new command
                try: 
                    await self.coordinator.async_override_device_interval(
                        device_id = self._device_id,
                        interval_id = intervals.index(interval),
                        interval_command = event_summary
                    )
                except Exception as err:
                    _LOGGER.error("Failed to update interval: %s", err)
                    raise HomeAssistantError(f"Failed to update interval: {err}") from err

                _LOGGER.info(f"Made and command override for device {self._device_id} updating command from {interval['command']} to {event_summary}")
                return
        
    async def async_added_to_hass(self):
        self.async_on_remove(
            self.hass.bus.async_listen(SCHEDULE_UPDATED_EVENT, self._handle_schedule_updated)
        )

    @callback
    def _handle_schedule_updated(self, event):
        self.async_write_ha_state()